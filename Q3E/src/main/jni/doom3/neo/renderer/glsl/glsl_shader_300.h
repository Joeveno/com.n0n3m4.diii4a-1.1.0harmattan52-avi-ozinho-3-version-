#ifndef _KARIN_GLSL_SHADER_330_H
#define _KARIN_GLSL_SHADER_330_H

// Unuse C++11 raw string literals for Traditional C++98

// diffuse map
GLSL_SHADER const char ES3_DEFAULT_VERT[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"in lowp vec4 attr_Color;\n"
"in vec4 attr_TexCoord;\n"
"in highp vec4 attr_Vertex;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform mat4 u_textureMatrix;\n"
"uniform lowp vec4 u_colorAdd;\n"
"uniform lowp vec4 u_colorModulate;\n"
"\n"
"out vec2 var_TexDiffuse;\n"
"out lowp vec4 var_Color;\n"
"\n"
"void main(void)\n"
"{\n"
	"var_TexDiffuse = (u_textureMatrix * attr_TexCoord).xy;\n"
"\n"
	"var_Color = (attr_Color / 255.0) * u_colorModulate + u_colorAdd;\n"
"\n"
	"gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"}\n"
;
GLSL_SHADER const char ES3_DEFAULT_FRAG[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"uniform sampler2D u_fragmentMap0;\n"
"uniform lowp vec4 u_glColor;\n"
"\n"
"in vec2 var_TexDiffuse;\n"
"in lowp vec4 var_Color;\n"
"out vec4 _gl_FragColor;\n"
"\n"
"void main(void)\n"
"{\n"
	"_gl_FragColor = texture(u_fragmentMap0, var_TexDiffuse) * u_glColor * var_Color;\n"
"}\n"
;

// shadow
GLSL_SHADER const char ES3_SHADOW_VERT[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"in highp vec4 attr_Vertex;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform lowp vec4 u_glColor;\n"
"uniform vec4 u_lightOrigin;\n"
"\n"
"out lowp vec4 var_Color;\n"
"\n"
"void main(void)\n"
"{\n"
	"gl_Position = u_modelViewProjectionMatrix * (attr_Vertex.w * u_lightOrigin + attr_Vertex - u_lightOrigin);\n"
"\n"
	"var_Color = u_glColor;\n"
"}\n"
;
GLSL_SHADER const char ES3_SHADOW_FRAG[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision lowp float;\n"
"\n"
"in lowp vec4 var_Color;\n"
"out vec4 _gl_FragColor;\n"
"\n"
"void main(void)\n"
"{\n"
	"_gl_FragColor = var_Color;\n"
"}\n"
;

// HeatHaze
GLSL_SHADER const char ES3_HEATHAZE_VERT[] =
        "#version 300 es\n"
        "//#pragma optimize(off)\n"
        "\n"
        "precision mediump float;\n"
        "\n"
        "in vec4 attr_TexCoord;\n"
        "in highp vec4 attr_Vertex;\n"
        "\n"
        "uniform highp mat4 u_modelViewProjectionMatrix;\n"
        "uniform highp mat4 u_modelViewMatrix;\n"
        "uniform highp mat4 u_projectionMatrix;\n"
        "\n"
		"uniform highp vec4 u_vertexParm0; // texture scrolling\n"
		"uniform highp vec4 u_vertexParm1; // magnitude of the distortion\n"
        "\n"
        "out highp vec4 var_TexCoord1;\n"
        "out highp vec4 var_TexCoord2;\n"
        "\n"
        "// # input:\n"
        "// #\n"
        "// # texcoord[0] TEX0 texcoords\n"
        "// #\n"
        "// # local[0] scroll\n"
        "// # local[1] deform magnitude (1.0 is reasonable, 2.0 is twice as wavy, 0.5 is half as wavy, etc)\n"
        "// #\n"
        "// # output:\n"
        "// #\n"
        "// # texture 0 is _currentRender\n"
        "// # texture 1 is a normal map that we will use to deform texture 0\n"
        "// #\n"
        "// # texCoord[1] is the model surface texture coords with a scroll\n"
        "// # texCoord[2] is the copied deform magnitude\n"
		"void main(void)\n"
		"{\n"
#if HEATHAZE_BFG // BFG
            "// texture 0 takes the texture coordinates and adds a scroll\n"
            "vec4 textureScroll = u_vertexParm0;\n"
            "var_TexCoord1 = vec4( attr_TexCoord.xy, 0.0, 0.0 ) + textureScroll;\n"
            "// texture 1 takes the deform magnitude and scales it by the projection distance\n"
            "vec4 vec = vec4( 0.0, 1.0, 0.0, 1.0 );\n"
            "vec.z  = dot( attr_Vertex, u_modelViewMatrix[2] );\n"
            "// magicProjectionAdjust is a magic scalar that scales the projection since we changed from \n"
            "// using the X axis to the Y axis to calculate R1.  It is an approximation to closely match \n"
            "// what the original game did\n"
            "const float magicProjectionAdjust = 0.43f;\n"
            "float x = dot ( vec, u_projectionMatrix[1] ) * magicProjectionAdjust;\n"
            "float w = dot ( vec, u_projectionMatrix[3] );\n"
            "// don't let the recip get near zero for polygons that cross the view plane\n"
            "w = max( w, 1.0 );\n"
            "x /= w;\n"
            "// clamp the distance so the the deformations don't get too wacky near the view\n"
            "x = min( x, 0.02 );\n"
            "vec4 deformMagnitude = u_vertexParm1;\n"
            "var_TexCoord2 = vec4(x) * deformMagnitude;\n"
		    "gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"

#else // 2004

            " vec4 R0, R1, R2; // TEMP R0, R1, R2;\n"
            "\n"
            " // # texture 1 takes the texture coordinates and adds a scroll\n"
            " var_TexCoord1 = (attr_TexCoord) + (u_vertexParm0); // ADD  result.texcoord[1], vertex.texcoord[0], program.local[0];\n"
            "\n"
            " // # texture 2 takes the deform magnitude and scales it by the projection distance\n"
            " vec4 vec = vec4(1.0, 0.0, 0.0, 1.0); // PARAM vec = { 1, 0, 0, 1 };\n"
            "\n"
            " R0 = vec; // MOV  R0, vec;\n"
            " R0.z = dot(attr_Vertex, (u_modelViewMatrix)[2]); // DP4  R0.z, vertex.position, state.matrix.modelview.row[2];\n"
            "\n"
            " R1 = vec4(dot(R0, (u_projectionMatrix)[0])); // DP4  R1, R0, state.matrix.projection.row[0];\n"
            " R2 = vec4(dot(R0, (u_projectionMatrix)[3])); // DP4  R2, R0, state.matrix.projection.row[3];\n"
            "\n"
            " // # don't let the recip get near zero for polygons that cross the view plane\n"
            " R2 = max(R2, vec4(1.0)); // MAX  R2, R2, 1;\n"
            "\n"
            " R2 = vec4(1.0 / R2.w); // RCP  R2, R2.w;\n"
            " R1 = (R1) * (R2); // MUL  R1, R1, R2;\n"
            "\n"
            " // # clamp the distance so the the deformations don't get too wacky near the view\n"
            " R1 = min(R1, vec4(0.02)); // MIN  R1, R1, 0.02;\n"
            "\n"
            " var_TexCoord2 = (R1) * (u_vertexParm1); // MUL  result.texcoord[2], R1, program.local[1];\n"
            "\n"
            " gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
#endif
"}\n"
;
GLSL_SHADER const char ES3_HEATHAZE_FRAG[] =
        "#version 300 es\n"
        "//#pragma optimize(off)\n"
        "\n"
        "precision mediump float;\n"
        "\n"
        "uniform sampler2D u_fragmentMap0;\n"
        "uniform sampler2D u_fragmentMap1;\n"
		"uniform highp vec4 u_nonPowerOfTwo;\n"
		"uniform highp vec4 u_windowCoords;\n"
        "in highp vec4 var_TexCoord1;\n"
        "in highp vec4 var_TexCoord2;\n"
        "out vec4 _gl_FragColor;\n"
        "\n"
        "// # texture 0 is _currentRender\n"
        "// # texture 1 is a normal map that we will use to deform texture 0\n"
        "// #\n"
        "// # env[0] is the 1.0 to _currentRender conversion\n"
        "// # env[1] is the fragment.position to 0.0 - 1.0 conversion\n"
		"void main(void)\n"
		"{\n"
#if HEATHAZE_BFG // BFG
            "// load the filtered normal map and convert to -1 to 1 range\n"
            "vec4 bumpMap = ( texture( u_fragmentMap1, var_TexCoord1.xy ) * 2.0f ) - 1.0f;\n"
            "vec2 localNormal = bumpMap.wy;\n"
            "// calculate the screen texcoord in the 0.0 to 1.0 range\n"
            "vec2 screenTexCoord = (gl_FragCoord.xy ) * u_windowCoords.xy;\n"
            "screenTexCoord += ( localNormal * var_TexCoord2.xy );\n"
            "screenTexCoord = clamp( screenTexCoord, vec2(0.0), vec2(1.0) );\n"
            "screenTexCoord = screenTexCoord * u_nonPowerOfTwo.xy;\n"
            "_gl_FragColor = texture( u_fragmentMap0, screenTexCoord );\n"

#else // 2004

            " vec4 localNormal, R0; // TEMP localNormal, R0;\n"
            "\n"
            " vec4 subOne = vec4(-1.0, -1.0, -1.0, -1.0); // PARAM subOne = { -1, -1, -1, -1 };\n"
            " vec4 scaleTwo = vec4(2.0, 2.0, 2.0, 2.0); // PARAM scaleTwo = { 2, 2, 2, 2 };\n"
            "\n"
            " //# load the filtered normal map and convert to -1 to 1 range\n"
            " localNormal = texture(u_fragmentMap1, var_TexCoord1.xy); // TEX  localNormal, fragment.texcoord[1], texture[1], 2D;\n"
            " localNormal.x = localNormal.a; // MOV  localNormal.x, localNormal.a;\n"
            " localNormal = (localNormal) * (scaleTwo) + (subOne); // MAD  localNormal, localNormal, scaleTwo, subOne;\n"
            " //localNormal.z = sqrt(max(0.0, 1.0-localNormal.x*localNormal.x-localNormal.y*localNormal.y));\n"
            "\n"
            " // # calculate the screen texcoord in the 0.0 to 1.0 range\n"
            " R0 = (gl_FragCoord) * (u_windowCoords); // MUL  R0, fragment.position, program.env[1];\n"
            "\n"
            " //localNormal.x /= localNormal.z;\n"
            " //localNormal.y /= localNormal.z;\n"
            "\n"
            " // # offset by the scaled localNormal and clamp it to 0.0 - 1.0\n"
            " R0 = clamp((localNormal) * (var_TexCoord2) + (R0), 0.0, 1.0); // MAD_SAT R0, localNormal, fragment.texcoord[2], R0;\n"
            "\n"
            " // # scale by the screen non-power-of-two-adjust\n"
            " R0 = (R0) * (u_nonPowerOfTwo); // MUL  R0, R0, program.env[0];\n"
            "\n"
            " // # load the screen render\n"
            " _gl_FragColor = texture(u_fragmentMap0, R0.xy); // TEX  result.color.xyz, R0, texture[0], 2D;\n"
#endif
"}\n"
;

GLSL_SHADER const char ES3_HEATHAZEWITHMASK_VERT[] =
		"#version 300 es\n"
		"//#pragma optimize(off)\n"
		"\n"
		"precision mediump float;\n"
		"\n"
		"in vec4 attr_TexCoord;\n"
		"in highp vec4 attr_Vertex;\n"
		"\n"
		"uniform highp mat4 u_modelViewProjectionMatrix;\n"
		"uniform highp mat4 u_modelViewMatrix;\n"
		"uniform highp mat4 u_projectionMatrix;\n"
		"\n"
		"uniform highp vec4 u_vertexParm0; // texture scrolling\n"
		"uniform highp vec4 u_vertexParm1; // magnitude of the distortion\n"
		"\n"
		"out highp vec4 var_TexCoord0;\n"
		"out highp vec4 var_TexCoord1;\n"
		"out highp vec4 var_TexCoord2;\n"
		"\n"
        "// # input:\n"
        "// #\n"
        "// # texcoord[0] TEX0 texcoords\n"
        "// #\n"
        "// # local[0] scroll\n"
        "// # local[1] deform magnitude (1.0 is reasonable, 2.0 is twice as wavy, 0.5 is half as wavy, etc)\n"
        "// #\n"
        "// # output:\n"
        "// #\n"
        "// # texture 0 is _currentRender\n"
        "// # texture 1 is a normal map that we will use to deform texture 0\n"
        "// # texture 2 is a mask texture\n"
        "// #\n"
        "// # texCoord[0] is the model surface texture coords unmodified for the mask\n"
        "// # texCoord[1] is the model surface texture coords with a scroll\n"
        "// # texCoord[2] is the copied deform magnitude\n"
		"void main(void)\n"
		"{\n"
#if HEATHAZE_BFG // BFG
            "// texture 0 takes the texture coordinates unmodified\n"
            "var_TexCoord0 = vec4( attr_TexCoord.xy, 0.0, 0.0 );\n"
            "// texture 1 takes the texture coordinates and adds a scroll\n"
            "vec4 textureScroll = u_vertexParm0;\n"
            "var_TexCoord1 = vec4( attr_TexCoord.xy, 0.0, 0.0 ) + textureScroll;\n"
            "// texture 2 takes the deform magnitude and scales it by the projection distance\n"
            "vec4 vec = vec4( 0.0, 1.0, 0.0, 1.0 );\n"
            "vec.z  = dot( attr_Vertex, u_modelViewMatrix[2] );\n"
            "// magicProjectionAdjust is a magic scalar that scales the projection since we changed from \n"
            "// using the X axis to the Y axis to calculate R1.  It is an approximation to closely match \n"
            "// what the original game did\n"
            "const float magicProjectionAdjust = 0.43f;\n"
            "float x = dot ( vec, u_projectionMatrix[1] ) * magicProjectionAdjust;\n"
            "float w = dot ( vec, u_projectionMatrix[3] );\n"
            "// don't let the recip get near zero for polygons that cross the view plane\n"
            "w = max( w, 1.0 );\n"
            "x /= w;\n"
            "// clamp the distance so the the deformations don't get too wacky near the view\n"
            "x = min( x, 0.02 );\n"
            "vec4 deformMagnitude = u_vertexParm1;\n"
            "var_TexCoord2 = vec4(x) * deformMagnitude;\n"
		    "gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"

#else // 2004

            " vec4 R0, R1, R2; // TEMP R0, R1, R2;\n"
            "\n"
            " // # texture 0 takes the texture coordinates unmodified\n"
            " var_TexCoord0 = attr_TexCoord; // MOV  result.texcoord[0], vertex.texcoord[0];\n"
            "\n"
            " // # texture 1 takes the texture coordinates and adds a scroll\n"
            " var_TexCoord1 = (attr_TexCoord) + (u_vertexParm0); // ADD  result.texcoord[1], vertex.texcoord[0], program.local[0];\n"
            "\n"
            " // # texture 2 takes the deform magnitude and scales it by the projection distance\n"
            " vec4 vec = vec4(1.0, 0.0, 0.0, 1.0); // PARAM vec = { 1, 0, 0, 1 };\n"
            "\n"
            " R0 = vec; // MOV  R0, vec;\n"
            " R0.z = dot(attr_Vertex, (u_modelViewMatrix)[2]); // DP4  R0.z, vertex.position, state.matrix.modelview.row[2];\n"
            "\n"
            " R1 = vec4(dot(R0, (u_projectionMatrix)[0])); // DP4  R1, R0, state.matrix.projection.row[0];\n"
            " R2 = vec4(dot(R0, (u_projectionMatrix)[3])); // DP4  R2, R0, state.matrix.projection.row[3];\n"
            "\n"
            " // # don't let the recip get near zero for polygons that cross the view plane\n"
            " R2 = max(R2, vec4(1.0)); // MAX  R2, R2, 1;\n"
            "\n"
            " R2 = vec4(1.0 / R2.w); // RCP  R2, R2.w;\n"
            " R1 = (R1) * (R2); // MUL  R1, R1, R2;\n"
            "\n"
            " // # clamp the distance so the the deformations don't get too wacky near the view\n"
            " R1 = min(R1, vec4(0.02)); // MIN  R1, R1, 0.02;\n"
            "\n"
            " var_TexCoord2 = (R1) * (u_vertexParm1); // MUL  result.texcoord[2], R1, program.local[1];\n"
            "\n"
            " gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
#endif
		"}\n"
;
GLSL_SHADER const char ES3_HEATHAZEWITHMASK_FRAG[] =
		"#version 300 es\n"
		"//#pragma optimize(off)\n"
		"\n"
		"precision mediump float;\n"
		"\n"
		"uniform sampler2D u_fragmentMap0;\n"
		"uniform sampler2D u_fragmentMap1;\n"
		"uniform sampler2D u_fragmentMap2;\n"
		"uniform highp vec4 u_nonPowerOfTwo;\n"
		"uniform highp vec4 u_windowCoords;\n"
		"in highp vec4 var_TexCoord0;\n"
		"in highp vec4 var_TexCoord1;\n"
		"in highp vec4 var_TexCoord2;\n"
		"out vec4 _gl_FragColor;\n"
		"\n"
        "// # texture 0 is _currentRender\n"
        "// # texture 1 is a normal map that we will use to deform texture 0\n"
        "// # texture 2 is a mask texture\n"
        "// #\n"
        "// # env[0] is the 1.0 to _currentRender conversion\n"
        "// # env[1] is the fragment.position to 0.0 - 1.0 conversion\n"
		"void main(void)\n"
		"{\n"
#if HEATHAZE_BFG // BFG
            "// load the distortion map\n"
            "vec4 mask = texture( u_fragmentMap2, var_TexCoord0.xy );\n"
            "// kill the pixel if the distortion wound up being very small\n"
            "mask.xy -= 0.01f;\n"
            " if ( any( lessThan( mask, vec4( 0.0 ) ) ) ) { discard; } \n"
            "// load the filtered normal map and convert to -1 to 1 range\n"
            "vec4 bumpMap = ( texture( u_fragmentMap1, var_TexCoord1.xy ) * 2.0f ) - 1.0f;\n"
            "vec2 localNormal = bumpMap.wy;\n"
            "localNormal *= mask.xy;\n"
            "// calculate the screen texcoord in the 0.0 to 1.0 range\n"
            "vec2 screenTexCoord = (gl_FragCoord.xy ) * u_windowCoords.xy;\n"
            "screenTexCoord += ( localNormal * var_TexCoord2.xy );\n"
            "screenTexCoord = clamp( screenTexCoord, vec2(0.0), vec2(1.0) );\n"
            "screenTexCoord = screenTexCoord * u_nonPowerOfTwo.xy;\n"
            "_gl_FragColor = texture( u_fragmentMap0, screenTexCoord );\n"

#else // 2004

            " vec4 localNormal, mask, R0; // TEMP localNormal, mask, R0;\n"
            "\n"
            " vec4 subOne = vec4(-1.0, -1.0, -1.0, -1.0); // PARAM subOne = { -1, -1, -1, -1 };\n"
            " vec4 scaleTwo = vec4(2.0, 2.0, 2.0, 2.0); // PARAM scaleTwo = { 2, 2, 2, 2 };\n"
            "\n"
            " // # load the distortion map\n"
            " mask = texture(u_fragmentMap2, var_TexCoord0.xy); // TEX  mask, fragment.texcoord[0], texture[2], 2D;\n"
            "\n"
            " // # kill the pixel if the distortion wound up being very small\n"
            " mask.xy = (mask.xy) - (vec2(0.01)); // SUB  mask.xy, mask, 0.01;\n"
            " if (any(lessThan(mask, vec4(0.0)))) discard; // KIL  mask;\n"
            "\n"
            " //# load the filtered normal map and convert to -1 to 1 range\n"
            " localNormal = texture(u_fragmentMap1, var_TexCoord1.xy); // TEX  localNormal, fragment.texcoord[1], texture[1], 2D;\n"
            " localNormal.x = localNormal.a; // MOV  localNormal.x, localNormal.a;\n"
            " localNormal = (localNormal) * (scaleTwo) + (subOne); // MAD  localNormal, localNormal, scaleTwo, subOne;\n"
            " //localNormal.z = sqrt(max(0.0, 1.0-localNormal.x*localNormal.x-localNormal.y*localNormal.y));\n"
            " localNormal = (localNormal) * (mask); // MUL  localNormal, localNormal, mask;\n"
            "\n"
            " // # calculate the screen texcoord in the 0.0 to 1.0 range\n"
            " R0 = (gl_FragCoord) * (u_windowCoords); // MUL  R0, fragment.position, program.env[1];\n"
            "\n"
            " //localNormal.x /= localNormal.z;\n"
            " //localNormal.y /= localNormal.z;\n"
            "\n"
            " // # offset by the scaled localNormal and clamp it to 0.0 - 1.0\n"
            " R0 = clamp((localNormal) * (var_TexCoord2) + (R0), 0.0, 1.0); // MAD_SAT R0, localNormal, fragment.texcoord[2], R0;\n"
            "\n"
            " // # scale by the screen non-power-of-two-adjust\n"
            " R0 = (R0) * (u_nonPowerOfTwo); // MUL  R0, R0, program.env[0];\n"
            "\n"
            " // # load the screen render\n"
            " _gl_FragColor = texture(u_fragmentMap0, R0.xy); // TEX  result.color.xyz, R0, texture[0], 2D;\n"
#endif
		"}\n"
;

GLSL_SHADER const char ES3_HEATHAZEWITHMASKANDVERTEX_VERT[] =
		"#version 300 es\n"
		"//#pragma optimize(off)\n"
		"\n"
		"precision mediump float;\n"
		"\n"
		"in vec4 attr_TexCoord;\n"
		"in highp vec4 attr_Vertex;\n"
		"in highp vec4 attr_Color;\n"
		"\n"
		"uniform highp mat4 u_modelViewProjectionMatrix;\n"
		"uniform highp mat4 u_modelViewMatrix;\n"
		"uniform highp mat4 u_projectionMatrix;\n"
		"\n"
		"uniform highp vec4 u_vertexParm0; // texture scrolling\n"
		"uniform highp vec4 u_vertexParm1; // magnitude of the distortion\n"
		"\n"
		"out highp vec4 var_TexCoord0;\n"
		"out highp vec4 var_TexCoord1;\n"
		"out highp vec4 var_TexCoord2;\n"
		"out lowp vec4 var_Color;\n"
		"\n"
        "// # input:\n"
        "// #\n"
        "// # texcoord[0] TEX0 texcoords\n"
        "// # color    vertex color for particle fading, will be multiplied by the mask texture\n"
        "// #\n"
        "// # local[0] scroll\n"
        "// # local[1] deform magnitude (1.0 is reasonable, 2.0 is twice as wavy, 0.5 is half as wavy, etc)\n"
        "// #\n"
        "// # output:\n"
        "// #\n"
        "// # texture 0 is _currentRender\n"
        "// # texture 1 is a normal map that we will use to deform texture 0\n"
        "// # texture 2 is a mask texture\n"
        "// #\n"
        "// # texCoord[0] is the model surface texture coords unmodified for the mask\n"
        "// # texCoord[1] is the model surface texture coords with a scroll\n"
        "// # texCoord[2] is the copied deform magnitude\n"
        "// # color is the copied vertex color\n"
		"void main(void)\n"
		"{\n"
#if HEATHAZE_BFG // BFG
            "// texture 0 takes the texture coordinates unmodified\n"
            "var_TexCoord0 = vec4( attr_TexCoord.xy, 0.0, 0.0 );\n"
            "// texture 1 takes the texture coordinates and adds a scroll\n"
            "vec4 textureScroll = u_vertexParm0;\n"
            "var_TexCoord1 = vec4( attr_TexCoord.xy, 0.0, 0.0 ) + textureScroll;\n"
            "// texture 2 takes the deform magnitude and scales it by the projection distance\n"
            "vec4 vec = vec4( 0.0, 1.0, 0.0, 1.0 );\n"
            "vec.z  = dot( attr_Vertex, u_modelViewMatrix[2] );\n"
            "// magicProjectionAdjust is a magic scalar that scales the projection since we changed from \n"
            "// using the X axis to the Y axis to calculate x.  It is an approximation to closely match \n"
            "// what the original game did\n"
            "const float magicProjectionAdjust = 0.43f;\n"
            "float x = dot ( vec, u_projectionMatrix[1] ) * magicProjectionAdjust;\n"
            "float w = dot ( vec, u_projectionMatrix[3] );\n"
            "// don't let the recip get near zero for polygons that cross the view plane\n"
            "w = max( w, 1.0 );\n"
            "x /= w;\n"
            "// clamp the distance so the the deformations don't get too wacky near the view\n"
            "x = min( x, 0.02 );\n"
            "vec4 deformMagnitude = u_vertexParm1;\n"
            "var_TexCoord2 = vec4(x) * deformMagnitude;\n"
            "var_Color = attr_Color / 255.0;\n"
		    "gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"

#else // 2004

            " vec4 R0, R1, R2; // TEMP R0, R1, R2;\n"
            "\n"
            " // # texture 0 takes the texture coordinates unmodified\n"
            " var_TexCoord0 = attr_TexCoord; // MOV  result.texcoord[0], vertex.texcoord[0];\n"
            "\n"
            " // # texture 1 takes the texture coordinates and adds a scroll\n"
            " var_TexCoord1 = (attr_TexCoord) + (u_vertexParm0); // ADD  result.texcoord[1], vertex.texcoord[0], program.local[0];\n"
            "\n"
            " // # texture 2 takes the deform magnitude and scales it by the projection distance\n"
            " vec4 vec = vec4(1.0, 0.0, 0.0, 1.0); // PARAM vec = { 1, 0, 0, 1 };\n"
            "\n"
            " R0 = vec; // MOV  R0, vec;\n"
            " R0.z = dot(attr_Vertex, (u_modelViewMatrix)[2]); // DP4  R0.z, vertex.position, state.matrix.modelview.row[2];\n"
            "\n"
            " R1 = vec4(dot(R0, (u_projectionMatrix)[0])); // DP4  R1, R0, state.matrix.projection.row[0];\n"
            " R2 = vec4(dot(R0, (u_projectionMatrix)[3])); // DP4  R2, R0, state.matrix.projection.row[3];\n"
            "\n"
            " // # don't let the recip get near zero for polygons that cross the view plane\n"
            " R2 = max(R2, vec4(1.0)); // MAX  R2, R2, 1;\n"
            "\n"
            " R2 = vec4(1.0 / R2.w); // RCP  R2, R2.w;\n"
            " R1 = (R1) * (R2); // MUL  R1, R1, R2;\n"
            "\n"
            " // # clamp the distance so the the deformations don't get too wacky near the view\n"
            " R1 = min(R1, vec4(0.02)); // MIN  R1, R1, 0.02;\n"
            "\n"
            " var_TexCoord2 = (R1) * (u_vertexParm1); // MUL  result.texcoord[2], R1, program.local[1];\n"
            "\n"
            " var_Color = attr_Color / 255.0; // MOV  result.color, vertex.color;\n"
            "\n"
            " gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
#endif
		"}\n"
;
GLSL_SHADER const char ES3_HEATHAZEWITHMASKANDVERTEX_FRAG[] =
		"#version 300 es\n"
		"//#pragma optimize(off)\n"
		"\n"
		"precision mediump float;\n"
		"\n"
		"uniform sampler2D u_fragmentMap0;\n"
		"uniform sampler2D u_fragmentMap1;\n"
		"uniform sampler2D u_fragmentMap2;\n"
		"uniform highp vec4 u_nonPowerOfTwo;\n"
		"uniform highp vec4 u_windowCoords;\n"
		"in highp vec4 var_TexCoord0;\n"
		"in highp vec4 var_TexCoord1;\n"
		"in highp vec4 var_TexCoord2;\n"
		"in lowp vec4 var_Color;\n"
		"out vec4 _gl_FragColor;\n"
		"\n"
        "// # texture 0 is _currentRender\n"
        "// # texture 1 is a normal map that we will use to deform texture 0\n"
        "// # texture 2 is a mask texture\n"
        "// #\n"
        "// # env[0] is the 1.0 to _currentRender conversion\n"
        "// # env[1] is the fragment.position to 0.0 - 1.0 conversion\n"
		"void main(void)\n"
		"{\n"
#if HEATHAZE_BFG // BFG
            "// load the distortion map\n"
            "vec4 mask = texture( u_fragmentMap2, var_TexCoord0.xy );\n"
            "// kill the pixel if the distortion wound up being very small\n"
            "mask.xy *= var_Color.xy;\n"
            "mask.xy -= 0.01f;\n"
            " if ( any( lessThan( mask, vec4( 0.0 ) ) ) ) { discard; } \n"
            "// load the filtered normal map and convert to -1 to 1 range\n"
            "vec4 bumpMap = ( texture( u_fragmentMap1, var_TexCoord1.xy ) * 2.0f ) - 1.0f;\n"
            "vec2 localNormal = bumpMap.wy;\n"
            "localNormal *= mask.xy;\n"
            "// calculate the screen texcoord in the 0.0 to 1.0 range\n"
            "vec2 screenTexCoord = (gl_FragCoord.xy ) * u_windowCoords.xy;\n"
            "screenTexCoord += ( localNormal * var_TexCoord2.xy );\n"
            "screenTexCoord = clamp( screenTexCoord, vec2(0.0), vec2(1.0) );\n"
            "screenTexCoord = screenTexCoord * u_nonPowerOfTwo.xy;\n"
            "_gl_FragColor = texture( u_fragmentMap0, screenTexCoord );\n"

#else // 2004

            " vec4 localNormal, mask, R0; // TEMP localNormal, mask, R0;\n"
            "\n"
            " vec4 subOne = vec4(-1.0, -1.0, -1.0, -1.0); // PARAM subOne = { -1, -1, -1, -1 };\n"
            " vec4 scaleTwo = vec4(2.0, 2.0, 2.0, 2.0); // PARAM scaleTwo = { 2, 2, 2, 2 };\n"
            "\n"
            " // # load the distortion map\n"
            " mask = texture(u_fragmentMap2, var_TexCoord0.xy); // TEX  mask, fragment.texcoord[0], texture[2], 2D;\n"
            "\n"
            " // # kill the pixel if the distortion wound up being very small\n"
            " //k mask.xy *= var_Color.xy; // MUL  mask.xy, mask, fragment.color;\n"
            " mask.xy = (mask.xy) - (vec2(0.01)); // SUB  mask.xy, mask, 0.01;\n"
            " if (any(lessThan(mask, vec4(0.0)))) discard; // KIL  mask;\n"
            "\n"
            " //# load the filtered normal map and convert to -1 to 1 range\n"
            " localNormal = texture(u_fragmentMap1, var_TexCoord1.xy); // TEX  localNormal, fragment.texcoord[1], texture[1], 2D;\n"
            " localNormal.x = localNormal.a; // MOV  localNormal.x, localNormal.a;\n"
            " localNormal = (localNormal) * (scaleTwo) + (subOne); // MAD  localNormal, localNormal, scaleTwo, subOne;\n"
            " //localNormal.z = sqrt(max(0.0, 1.0-localNormal.x*localNormal.x-localNormal.y*localNormal.y));\n"
            " localNormal = (localNormal) * (mask); // MUL  localNormal, localNormal, mask;\n"
            "\n"
            " // # calculate the screen texcoord in the 0.0 to 1.0 range\n"
            " R0 = (gl_FragCoord) * (u_windowCoords); // MUL  R0, fragment.position, program.env[1];\n"
            "\n"
            " //localNormal.x /= localNormal.z;\n"
            " //localNormal.y /= localNormal.z;\n"
            "\n"
            " // # offset by the scaled localNormal and clamp it to 0.0 - 1.0\n"
            " R0 = clamp((localNormal) * (var_TexCoord2) + (R0), 0.0, 1.0); // MAD_SAT R0, localNormal, fragment.texcoord[2], R0;\n"
            "\n"
            " // # scale by the screen non-power-of-two-adjust\n"
            " R0 = (R0) * (u_nonPowerOfTwo); // MUL  R0, R0, program.env[0];\n"
            "\n"
            " // # load the screen render\n"
            " _gl_FragColor = texture(u_fragmentMap0, R0.xy); // TEX  result.color.xyz, R0, texture[0], 2D;\n"
#endif
		"}\n"
;

// colorProcess
GLSL_SHADER const char ES3_COLORPROCESS_VERT[] =
        "#version 300 es\n"
        "//#pragma optimize(off)\n"
        "\n"
        "precision mediump float;\n"
        "\n"
        "in highp vec4 attr_Vertex;\n"
        "in highp vec4 attr_TexCoord;\n"
        "\n"
        "uniform highp mat4 u_modelViewProjectionMatrix;\n"
        "uniform highp vec4 u_vertexParm0; // fraction\n"
        "uniform highp vec4 u_vertexParm1; // target hue\n"
        "\n"
        "out highp vec4 var_TexCoord;\n"
        "out lowp vec4 var_Color;\n"
        "\n"
        "// # parameter 0 is the fraction from the current hue to the target hue to map\n"
        "// # parameter 1.rgb is the target hue\n"
        "// # texture 0 is _currentRender\n"
        "\n"
        "// # nothing to do but pass the parameters along\n"
        "void main(void)\n"
        "{\n"
            "gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
            "\n"
            "var_Color = u_vertexParm1;\n"
            "var_TexCoord.x = attr_TexCoord.x;\n"
            "var_TexCoord.y = 1.0f - attr_TexCoord.y;\n"
            "var_TexCoord.z = u_vertexParm0.x;\n"
        "}\n"
;
GLSL_SHADER const char ES3_COLORPROCESS_FRAG[] =
        "#version 300 es\n"
        "//#pragma optimize(off)\n"
        "\n"
        "precision mediump float;\n"
        "\n"
        "uniform sampler2D u_fragmentMap0;\n"
		"uniform highp vec4 u_nonPowerOfTwo;\n"
        "\n"
        "in highp vec4 var_TexCoord;\n"
        "in lowp vec4 var_Color;\n"
        "out vec4 _gl_FragColor;\n"
        "\n"
        "void main(void)\n"
        "{\n"
            "vec4 src = texture( u_fragmentMap0, var_TexCoord.xy * u_nonPowerOfTwo.xy /* scale by the screen non-power-of-two-adjust */ );\n"
            "vec4 target = var_Color * dot( vec3( 0.333, 0.333, 0.333 ), src.xyz );\n"
            "_gl_FragColor = mix( src, target, var_TexCoord.z );\n"
        "}\n"
;

// interaction
GLSL_SHADER const char ES3_INTERACTION_VERT[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision highp float;\n"
"\n"
"//#define BLINN_PHONG\n"
"\n"
"out vec2 var_TexDiffuse;\n"
"out vec2 var_TexNormal;\n"
"out vec2 var_TexSpecular;\n"
"out vec4 var_TexLight;\n"
"out lowp vec4 var_Color;\n"
"out vec3 var_L;\n"
"#if defined(BLINN_PHONG)\n"
"out vec3 var_H;\n"
"#else\n"
"out vec3 var_V;\n"
"#endif\n"
"\n"
"in vec4 attr_TexCoord;\n"
"in vec3 attr_Tangent;\n"
"in vec3 attr_Bitangent;\n"
"in vec3 attr_Normal;\n"
"in highp vec4 attr_Vertex;\n"
"in lowp vec4 attr_Color;\n"
"\n"
"uniform vec4 u_lightProjectionS;\n"
"uniform vec4 u_lightProjectionT;\n"
"uniform vec4 u_lightFalloff;\n"
"uniform vec4 u_lightProjectionQ;\n"
"uniform lowp vec4 u_colorModulate;\n"
"uniform lowp vec4 u_colorAdd;\n"
"uniform lowp vec4 u_glColor;\n"
"\n"
"uniform vec4 u_lightOrigin;\n"
"uniform vec4 u_viewOrigin;\n"
"\n"
"uniform vec4 u_bumpMatrixS;\n"
"uniform vec4 u_bumpMatrixT;\n"
"uniform vec4 u_diffuseMatrixS;\n"
"uniform vec4 u_diffuseMatrixT;\n"
"uniform vec4 u_specularMatrixS;\n"
"uniform vec4 u_specularMatrixT;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"\n"
"void main(void)\n"
"{\n"
	"mat3 M = mat3(attr_Tangent, attr_Bitangent, attr_Normal);\n"
"\n"
	"var_TexNormal.x = dot(u_bumpMatrixS, attr_TexCoord);\n"
	"var_TexNormal.y = dot(u_bumpMatrixT, attr_TexCoord);\n"
"\n"
	"var_TexDiffuse.x = dot(u_diffuseMatrixS, attr_TexCoord);\n"
	"var_TexDiffuse.y = dot(u_diffuseMatrixT, attr_TexCoord);\n"
"\n"
	"var_TexSpecular.x = dot(u_specularMatrixS, attr_TexCoord);\n"
	"var_TexSpecular.y = dot(u_specularMatrixT, attr_TexCoord);\n"
"\n"
	"var_TexLight.x = dot(u_lightProjectionS, attr_Vertex);\n"
	"var_TexLight.y = dot(u_lightProjectionT, attr_Vertex);\n"
	"var_TexLight.z = dot(u_lightFalloff, attr_Vertex);\n"
	"var_TexLight.w = dot(u_lightProjectionQ, attr_Vertex);\n"
"\n"
	"vec3 L = u_lightOrigin.xyz - attr_Vertex.xyz;\n"
	"vec3 V = u_viewOrigin.xyz - attr_Vertex.xyz;\n"
"#if defined(BLINN_PHONG)\n"
	"vec3 H = normalize(L) + normalize(V);\n"
"#endif\n"
"\n"
	"var_L = L * M;\n"
"#if defined(BLINN_PHONG)\n"
	"var_H = H * M;\n"
"#else\n"
	"var_V = V * M;\n"
"#endif\n"
"\n"
	"var_Color = (attr_Color / 255.0) * u_colorModulate + u_colorAdd;\n"
"\n"
	"gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"}\n"
;
GLSL_SHADER const char ES3_INTERACTION_FRAG[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision highp float;\n"
"\n"
"//#define BLINN_PHONG\n"
"\n"
"//#define HALF_LAMBERT\n"
"\n"
"in vec2 var_TexDiffuse;\n"
"in vec2 var_TexNormal;\n"
"in vec2 var_TexSpecular;\n"
"in vec4 var_TexLight;\n"
"in lowp vec4 var_Color;\n"
"in vec3 var_L;\n"
"#if defined(BLINN_PHONG)\n"
"in vec3 var_H;\n"
"#else\n"
"in vec3 var_V;\n"
"#endif\n"
"\n"
"uniform vec4 u_diffuseColor;\n"
"uniform vec4 u_specularColor;\n"
"uniform float u_specularExponent;\n"
"\n"
"uniform sampler2D u_fragmentMap0;	/* u_bumpTexture */\n"
"uniform sampler2D u_fragmentMap1;	/* u_lightFalloffTexture */\n"
"uniform sampler2D u_fragmentMap2;	/* u_lightProjectionTexture */\n"
"uniform sampler2D u_fragmentMap3;	/* u_diffuseTexture */\n"
"uniform sampler2D u_fragmentMap4;	/* u_specularTexture */\n"
"uniform sampler2D u_fragmentMap5;	/* u_specularFalloffTexture */\n"
"out vec4 _gl_FragColor;\n"
"\n"
"void main(void)\n"
"{\n"
	"//float u_specularExponent = 4.0;\n"
"\n"
	"vec3 L = normalize(var_L);\n"
"#if defined(BLINN_PHONG)\n"
	"vec3 H = normalize(var_H);\n"
	"vec3 N = 2.0 * texture(u_fragmentMap0, var_TexNormal.st).agb - 1.0;\n"
"#else\n"
	"vec3 V = normalize(var_V);\n"
	"vec3 N = normalize(2.0 * texture(u_fragmentMap0, var_TexNormal.st).agb - 1.0);\n"
"#endif\n"
"\n"
	"float NdotL = clamp(dot(N, L), 0.0, 1.0);\n"
"#if defined(HALF_LAMBERT)\n"
	"NdotL *= 0.5;\n"
	"NdotL += 0.5;\n"
	"NdotL = NdotL * NdotL;\n"
"#endif\n"
"#if defined(BLINN_PHONG)\n"
	"float NdotH = clamp(dot(N, H), 0.0, 1.0);\n"
"#endif\n"
"\n"
	"vec3 lightProjection = textureProj(u_fragmentMap2, var_TexLight.xyw).rgb;\n"
	"vec3 lightFalloff = texture(u_fragmentMap1, vec2(var_TexLight.z, 0.5)).rgb;\n"
	"vec3 diffuseColor = texture(u_fragmentMap3, var_TexDiffuse).rgb * u_diffuseColor.rgb;\n"
	"vec3 specularColor = 2.0 * texture(u_fragmentMap4, var_TexSpecular).rgb * u_specularColor.rgb;\n"
"\n"
"#if defined(BLINN_PHONG)\n"
	"float specularFalloff = pow(NdotH, u_specularExponent);\n"
"#else\n"
	"vec3 R = -reflect(L, N);\n"
	"float RdotV = clamp(dot(R, V), 0.0, 1.0);\n"
	"float specularFalloff = pow(RdotV, u_specularExponent);\n"
"#endif\n"
"\n"
	"vec3 color;\n"
	"color = diffuseColor;\n"
	"color += specularFalloff * specularColor;\n"
	"color *= NdotL * lightProjection;\n"
	"color *= lightFalloff;\n"
"\n"
	"_gl_FragColor = vec4(color, 1.0) * var_Color;\n"
"}\n"
;

// z-fill
GLSL_SHADER const char ES3_ZFILL_VERT[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"in vec4 attr_TexCoord;\n"
"in highp vec4 attr_Vertex;\n"
"\n"
"uniform mat4 u_textureMatrix;\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"\n"
"out vec2 var_TexDiffuse;\n"
"\n"
"void main(void)\n"
"{\n"
"	var_TexDiffuse = (u_textureMatrix * attr_TexCoord).xy;\n"
"\n"
"	gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"}\n"
;
GLSL_SHADER const char ES3_ZFILL_FRAG[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"uniform sampler2D u_fragmentMap0;\n"
"uniform lowp float u_alphaTest;\n"
"uniform lowp vec4 u_glColor;\n"
"\n"
"in vec2 var_TexDiffuse;\n"
"out vec4 _gl_FragColor;\n"
"\n"
"void main(void)\n"
"{\n"
	"if (u_alphaTest > texture(u_fragmentMap0, var_TexDiffuse).a) {\n"
		"discard;\n"
	"}\n"
"\n"
	"_gl_FragColor = u_glColor;\n"
"}\n"
;

// cubemap
GLSL_SHADER const char ES3_CUBEMAP_VERT[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"in lowp vec4 attr_Color;\n"
"in vec4 attr_TexCoord;\n"
"in highp vec4 attr_Vertex;\n"
  "\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform mat4 u_textureMatrix;\n"
"uniform lowp vec4 u_colorAdd;\n"
"uniform lowp vec4 u_colorModulate;\n"
"uniform vec4 u_viewOrigin;\n"
"\n"
"out vec3 var_TexCoord;\n"
"out lowp vec4 var_Color;\n"
"\n"
"void main(void)\n"
"{\n"
"  var_TexCoord = (u_textureMatrix * attr_TexCoord).xyz;\n"
"\n"
  "var_Color = (attr_Color / 255.0) * u_colorModulate + u_colorAdd;\n"
"\n"
  "gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"}\n"
;
GLSL_SHADER const char ES3_CUBEMAP_FRAG[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"in vec3 var_TexCoord;\n"
"in lowp vec4 var_Color;\n"
"\n"
"uniform samplerCube u_fragmentCubeMap0;\n"
"uniform lowp vec4 u_glColor;\n"
"out vec4 _gl_FragColor;\n"
"\n"
"void main(void)\n"
"{\n"
  "_gl_FragColor = texture(u_fragmentCubeMap0, var_TexCoord) * u_glColor * var_Color;\n"
"}\n"
;

// reflection cubemap
GLSL_SHADER const char ES3_REFLECTION_CUBEMAP_VERT[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"in highp vec4 attr_Vertex;\n"
"in lowp vec4 attr_Color;\n"
"in vec3 attr_TexCoord;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform mat4 u_modelViewMatrix;\n"
"uniform mat4 u_textureMatrix;\n"
"uniform lowp vec4 u_colorAdd;\n"
"uniform lowp vec4 u_colorModulate;\n"
"\n"
"out vec3 var_TexCoord;\n"
"out lowp vec4 var_Color;\n"
"\n"
"void main(void)\n"
"{\n"
  "var_TexCoord = (u_textureMatrix * reflect( normalize( u_modelViewMatrix * attr_Vertex ),\n"
                                            "// This suppose the modelView matrix is orthogonal\n"
                                            "// Otherwise, we should use the inverse transpose\n"
                                            "u_modelViewMatrix * vec4(attr_TexCoord,0.0) )).xyz ;\n"
"\n"
  "var_Color = (attr_Color / 255.0) * u_colorModulate + u_colorAdd;\n"
  "\n"
  "gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"}\n"
;

// fog
GLSL_SHADER const char ES3_FOG_VERT[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"in highp vec4 attr_Vertex;      // input Vertex Coordinates\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform mat4 u_fogMatrix;        // fogPlanes 0, 1, 3 (CATION: not 2!), 2\n"
"\n"
"out vec2 var_TexFog;         // output Fog TexCoord\n"
"out vec2 var_TexFogEnter;    // output FogEnter TexCoord\n"
"\n"
"void main(void)\n"
"{\n"
  "gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"\n"
  "// What will be computed:\n"
  "//\n"
  "// var_TexFog.x      = dot(u_fogMatrix[0], attr_Vertex);\n"
  "// var_TexFog.y      = dot(u_fogMatrix[1], attr_Vertex);\n"
  "// var_TexFogEnter.x = dot(u_fogMatrix[2], attr_Vertex);\n"
  "// var_TexFogEnter.y = dot(u_fogMatrix[3], attr_Vertex);\n"
"\n"
  "// Optimized version:\n"
  "var_TexFog      = vec2(dot(u_fogMatrix[0], attr_Vertex),dot(u_fogMatrix[1], attr_Vertex));\n"
  "var_TexFogEnter = vec2(dot(u_fogMatrix[2], attr_Vertex),dot(u_fogMatrix[3], attr_Vertex));\n"
"}\n"
;
GLSL_SHADER const char ES3_FOG_FRAG[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"in vec2 var_TexFog;            // input Fog TexCoord\n"
"in vec2 var_TexFogEnter;       // input FogEnter TexCoord\n"
"\n"
"uniform sampler2D u_fragmentMap0;   // Fog Image\n"
"uniform sampler2D u_fragmentMap1;   // Fog Enter Image\n"
"uniform lowp vec4 u_fogColor;       // Fog Color\n"
"out vec4 _gl_FragColor;\n"
"\n"
"void main(void)\n"
"{\n"
  "_gl_FragColor = texture( u_fragmentMap0, var_TexFog ) * texture( u_fragmentMap1, var_TexFogEnter ) * vec4(u_fogColor.rgb, 1.0);\n"
"}\n"
;

// blend light
GLSL_SHADER const char ES3_BLENDLIGHT_VERT[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"in highp vec4 attr_Vertex;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform mat4 u_fogMatrix;\n"
"\n"
"out vec2 var_TexFog;\n"
"out vec2 var_TexFogEnter;\n"
"\n"
"void main(void)\n"
"{\n"
  "gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"\n"
  "// What will be computed:\n"
  "//\n"
  "// vec4 tc;\n"
  "// tc.x = dot( u_fogMatrix[0], attr_Vertex );\n"
  "// tc.y = dot( u_fogMatrix[1], attr_Vertex );\n"
  "// tc.z = 0.0;\n"
  "// tc.w = dot( u_fogMatrix[2], attr_Vertex );\n"
  "// var_TexFog.xy = tc.xy / tc.w;\n"
  "//\n"
  "// var_TexFogEnter.x = dot( u_fogMatrix[3], attr_Vertex );\n"
  "// var_TexFogEnter.y = 0.5;\n"
"\n"
  "// Optimized version:\n"
  "//\n"
  "var_TexFog = vec2(dot( u_fogMatrix[0], attr_Vertex ), dot( u_fogMatrix[1], attr_Vertex )) / dot( u_fogMatrix[2], attr_Vertex );\n"
  "var_TexFogEnter = vec2( dot( u_fogMatrix[3], attr_Vertex ), 0.5 );\n"
"}\n"
;

// z-fill with clip plane
GLSL_SHADER const char ES3_ZFILLCLIP_VERT[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"in highp vec4 attr_Vertex;\n"
"in vec4 attr_TexCoord;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform mat4 u_textureMatrix;\n"
"uniform vec4 u_clipPlane;\n"
"\n"
"out vec2 var_TexDiffuse;\n"
"out vec2 var_TexClip;\n"
"\n"
"void main(void)\n"
"{\n"
"	var_TexDiffuse = (u_textureMatrix * attr_TexCoord).xy;\n"
"\n"
  "var_TexClip = vec2( dot( u_clipPlane, attr_Vertex), 0.5 );\n"
"\n"
  "gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"}\n"
;
GLSL_SHADER const char ES3_ZFILLCLIP_FRAG[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"in vec2 var_TexDiffuse;\n"
"in vec2 var_TexClip;\n"
"\n"
"uniform sampler2D u_fragmentMap0;\n"
"uniform sampler2D u_fragmentMap1;\n"
"uniform lowp float u_alphaTest;\n"
"uniform lowp vec4 u_glColor;\n"
"out vec4 _gl_FragColor;\n"
"\n"
"void main(void)\n"
"{\n"
    "if (u_alphaTest > (texture(u_fragmentMap0, var_TexDiffuse).a * texture(u_fragmentMap1, var_TexClip).a) ) {\n"
      "discard;\n"
    "}\n"
	"\n"
  "_gl_FragColor = u_glColor;\n"
"}\n"
;

// diffuse dubemap(UNUSED in game)
GLSL_SHADER const char ES3_DIFFUSE_CUBEMAP_VERT[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
  "\n"
"// In\n"
"in highp vec4 attr_Vertex;\n"
"in lowp vec4 attr_Color;\n"
"in vec3 attr_TexCoord;\n"
  "\n"
"// Uniforms\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform mat4 u_textureMatrix;\n"
"uniform lowp float u_colorAdd;\n"
"uniform lowp float u_colorModulate;\n"
  "\n"
"// Out\n"
"// gl_Position\n"
"out vec3 var_TexCoord;\n"
"out lowp vec4 var_Color;\n"
  "\n"
"void main(void)\n"
"{\n"
	"var_TexCoord = (u_textureMatrix * vec4(attr_TexCoord, 0.0)).xyz;\n"
"\n"
	"var_Color = (attr_Color / 255.0) * u_colorModulate + u_colorAdd;\n"
"\n"
  "gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"}\n"
;

// texgen(Only used in D3XP)
GLSL_SHADER const char ES3_TEXGEN_VERT[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"in highp vec4 attr_Vertex;\n"
"in lowp vec4 attr_Color;\n"
"\n"
"uniform lowp vec4 u_colorAdd;\n"
"uniform lowp vec4 u_colorModulate;\n"
"uniform vec4 u_texgenS;\n"
"uniform vec4 u_texgenT;\n"
"uniform vec4 u_texgenQ;\n"
"uniform mat4 u_textureMatrix;\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"\n"
"out vec4 var_TexCoord;\n"
"out lowp vec4 var_Color;\n"
"\n"
"void main(void)\n"
"{\n"
	"gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"\n"
	"vec4 texcoord0 = vec4(dot( u_texgenS, attr_Vertex ), dot( u_texgenT, attr_Vertex ), 0.0, dot( u_texgenQ, attr_Vertex )); \n"
"\n"
	"// multiply the texture matrix in\n"
	"var_TexCoord = vec4(dot( u_textureMatrix[0], texcoord0 ), dot( u_textureMatrix[1], texcoord0), texcoord0.z, texcoord0.w);\n"
"\n"
	"// compute vertex modulation\n"
	"var_Color = (attr_Color / 255.0) * u_colorModulate + u_colorAdd;\n"
"}\n"
;
GLSL_SHADER const char ES3_TEXGEN_FRAG[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"uniform sampler2D u_fragmentMap0;\n"
"uniform lowp vec4 u_glColor;\n"
"\n"
"in vec4 var_TexCoord;\n"
"in lowp vec4 var_Color;\n"
"out vec4 _gl_FragColor;\n"
"\n"
"void main(void)\n"
"{\n"
	"// we always do a projective texture lookup so that we can support texgen\n"
	"// materials without a separate shader. Basic materials will have texture\n"
	"// coordinates with w = 1 which will result in a NOP projection when tex2Dproj\n"
	"// gets called.\n"
	"_gl_FragColor = textureProj( u_fragmentMap0, var_TexCoord.xyw ) * u_glColor * var_Color;\n"
"}\n"
;

#ifdef _SHADOW_MAPPING
// shadow map
GLSL_SHADER const char ES3_DEPTH_VERT[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision highp float;\n"
"\n"
"in highp vec4 attr_Vertex;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform highp mat4 u_modelMatrix;\n"
"uniform highp vec4 u_lightOrigin;\n"
"\n"
"uniform highp vec4 globalLightOrigin;\n"
"uniform lowp float u_uniformParm2; // .w 1.0 or 0.0\n"
"\n"
"void main(void)\n"
"{\n"
"	highp vec4 pos;\n"
"	//vec4 pos = attr_Vertex.w * u_lightOrigin + attr_Vertex - u_lightOrigin;\n"
"	//float w = max(attr_Vertex.w, u_uniformParm2);\n"
"	//vec4 pos = w * u_lightOrigin + vec4(attr_Vertex.xyz, w) - u_lightOrigin;\n"
"	//pos = attr_Vertex - u_lightOrigin; pos = (pos.wwww * u_lightOrigin) + pos;\n"
"	pos = vec4(attr_Vertex.xyz, 1.0);\n"
"	gl_Position = pos * u_modelViewProjectionMatrix;\n"
"}\n"
;
GLSL_SHADER const char ES3_DEPTH_FRAG[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision highp float;\n"
"\n"
"#ifdef _DEBUG\n"
"out vec4 _gl_FragColor;\n"
"#endif\n"
"\n"
"void main(void)\n"
"{\n"
"#ifdef _DEBUG\n"
"    _gl_FragColor = vec4((gl_FragCoord.z + 1.0) * 0.5, 0.0, 0.0, 1.0); // DEBUG\n"
"#endif\n"
"}\n"
;

// interaction(shadow mapping)
GLSL_SHADER const char ES3_INTERACTION_SHADOW_MAPPING_VERT[] =
        "#version 300 es\n"
        "//#pragma optimize(off)\n"
        "\n"
        "precision highp float;\n"
        "\n"
        "//#define BLINN_PHONG\n"
        "\n"
        "out vec2 var_TexDiffuse;\n"
        "out vec2 var_TexNormal;\n"
        "out vec2 var_TexSpecular;\n"
        "out vec4 var_TexLight;\n"
        "out lowp vec4 var_Color;\n"
        "out vec3 var_L;\n"
        "#if defined(BLINN_PHONG)\n"
        "out vec3 var_H;\n"
		"#else\n"
		"out vec3 var_V;\n"
        "#endif\n"
        "\n"
        "in vec4 attr_TexCoord;\n"
        "in vec3 attr_Tangent;\n"
        "in vec3 attr_Bitangent;\n"
        "in vec3 attr_Normal;\n"
        "in highp vec4 attr_Vertex;\n"
        "in lowp vec4 attr_Color;\n"
        "\n"
        "uniform vec4 u_lightProjectionS;\n"
        "uniform vec4 u_lightProjectionT;\n"
        "uniform vec4 u_lightFalloff;\n"
        "uniform vec4 u_lightProjectionQ;\n"
        "uniform lowp vec4 u_colorModulate;\n"
        "uniform lowp vec4 u_colorAdd;\n"
        "uniform lowp vec4 u_glColor;\n"
        "\n"
        "uniform vec4 u_lightOrigin;\n"
        "uniform vec4 u_viewOrigin;\n"
        "\n"
        "uniform vec4 u_bumpMatrixS;\n"
        "uniform vec4 u_bumpMatrixT;\n"
        "uniform vec4 u_diffuseMatrixS;\n"
        "uniform vec4 u_diffuseMatrixT;\n"
        "uniform vec4 u_specularMatrixS;\n"
        "uniform vec4 u_specularMatrixT;\n"
        "\n"
        "uniform highp mat4 u_modelViewProjectionMatrix;\n"
		"\n"
		"uniform highp mat4 u_modelMatrix;\n"
		"uniform highp vec4 globalLightOrigin;\n"
		"\n"
		"#ifdef _POINT_LIGHT\n"
        "   out highp vec4 var_VertexPosition;\n"
		"   out highp vec3 var_VertexToLight;\n"
		"#else\n"
		"   uniform highp mat4 shadowMVPMatrix;\n"
        "   out highp vec4 var_ShadowCoord;\n"
		"#endif\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "	mat3 M = mat3(attr_Tangent, attr_Bitangent, attr_Normal);\n"
        "\n"
        "	var_TexNormal.x = dot(u_bumpMatrixS, attr_TexCoord);\n"
        "	var_TexNormal.y = dot(u_bumpMatrixT, attr_TexCoord);\n"
        "\n"
        "	var_TexDiffuse.x = dot(u_diffuseMatrixS, attr_TexCoord);\n"
        "	var_TexDiffuse.y = dot(u_diffuseMatrixT, attr_TexCoord);\n"
        "\n"
        "	var_TexSpecular.x = dot(u_specularMatrixS, attr_TexCoord);\n"
        "	var_TexSpecular.y = dot(u_specularMatrixT, attr_TexCoord);\n"
        "\n"
        "	var_TexLight.x = dot(u_lightProjectionS, attr_Vertex);\n"
        "	var_TexLight.y = dot(u_lightProjectionT, attr_Vertex);\n"
        "	var_TexLight.z = dot(u_lightFalloff, attr_Vertex);\n"
        "	var_TexLight.w = dot(u_lightProjectionQ, attr_Vertex);\n"
        "\n"
        "	vec3 L = u_lightOrigin.xyz - attr_Vertex.xyz;\n"
        "	vec3 V = u_viewOrigin.xyz - attr_Vertex.xyz;\n"
        "#if defined(BLINN_PHONG)\n"
        "	vec3 H = normalize(L) + normalize(V);\n"
        "#endif\n"
        "\n"
        "	var_L = L * M;\n"
        "#if defined(BLINN_PHONG)\n"
        "	var_H = H * M;\n"
		"#else\n"
		"	var_V = V * M;\n"
        "#endif\n"
        "\n"
        "	var_Color = (attr_Color / 255.0) * u_colorModulate + u_colorAdd;\n"
        "\n"
		"#ifdef _POINT_LIGHT\n"
		"	highp vec4 posInLight = u_modelMatrix * attr_Vertex;\n"
		"	var_VertexToLight = globalLightOrigin.xyz - posInLight.xyz;\n"
        "	var_VertexPosition = attr_Vertex;\n"
		"#else\n"
        "	var_ShadowCoord = attr_Vertex * shadowMVPMatrix;\n"
		"#endif\n"
        "	gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
        "}\n"
;
GLSL_SHADER const char ES3_INTERACTION_SHADOW_MAPPING_FRAG[] =
        "#version 300 es\n"
        "//#pragma optimize(off)\n"
        "\n"
        "precision highp float;\n"
        "\n"
        "//#define BLINN_PHONG\n"
        "\n"
        "//#define HALF_LAMBERT\n"
        "\n"
        "in vec2 var_TexDiffuse;\n"
        "in vec2 var_TexNormal;\n"
        "in vec2 var_TexSpecular;\n"
        "in vec4 var_TexLight;\n"
        "in lowp vec4 var_Color;\n"
        "in vec3 var_L;\n"
        "#if defined(BLINN_PHONG)\n"
        "in vec3 var_H;\n"
        "#else\n"
        "in vec3 var_V;\n"
        "#endif\n"
        "\n"
        "uniform vec4 u_diffuseColor;\n"
        "uniform vec4 u_specularColor;\n"
        "uniform float u_specularExponent;\n"
        "\n"
        "uniform sampler2D u_fragmentMap0;	/* u_bumpTexture */\n"
        "uniform sampler2D u_fragmentMap1;	/* u_lightFalloffTexture */\n"
        "uniform sampler2D u_fragmentMap2;	/* u_lightProjectionTexture */\n"
        "uniform sampler2D u_fragmentMap3;	/* u_diffuseTexture */\n"
        "uniform sampler2D u_fragmentMap4;	/* u_specularTexture */\n"
        "uniform sampler2D u_fragmentMap5;	/* u_specularFalloffTexture */\n"
		"\n"
		"uniform highp vec4 globalLightOrigin;\n"
        "uniform highp float u_uniformParm2; // sample size\n"
		"uniform mediump float u_uniformParm3; // shadow alpha\n"
		"uniform highp float u_uniformParm4; // shadow bias\n"
		"uniform highp float u_uniformParm5; // 1.0 / textureSize()\n"
		"uniform highp float u_uniformParm6; // textureSize()\n"
		"uniform highp sampler2DArrayShadow u_fragmentMap6;	/* u_shadowMapTexture */\n"
		"#ifdef _POINT_LIGHT\n"
        "   in highp vec4 var_VertexPosition;\n"
		"   uniform highp mat4 shadowMVPMatrix[6];\n"
		"   in highp vec3 var_VertexToLight;\n"
		"#else\n"
        "   in highp vec4 var_ShadowCoord;\n"
		"#endif\n"
		"\n"
        "#ifdef _DYNAMIC_BIAS\n"
        "   #ifdef _PARALLEL_LIGHT\n"
		"        #define BIAS_SCALE 1.0 // 0.999991\n"
        "	#else\n"
		"        #define BIAS_SCALE 1.0 // 0.999\n"
        "   #endif\n"
		"   #define BIAS(x) ((x) * BIAS_SCALE)\n"
        "#else\n"
		"	#define BIAS_OFFSET 0.0 // 0.001\n"
		"   #define BIAS(x) ((x) - BIAS_OFFSET)\n"
        "#endif\n"
		"\n"
		"out vec4 _gl_FragColor;\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "	//float u_specularExponent = 4.0;\n"
        "\n"
        "	vec3 L = normalize(var_L);\n"
        "#if defined(BLINN_PHONG)\n"
        "	vec3 H = normalize(var_H);\n"
        "	vec3 N = 2.0 * texture(u_fragmentMap0, var_TexNormal.st).agb - 1.0;\n"
        "#else\n"
        "	vec3 V = normalize(var_V);\n"
        "	vec3 N = normalize(2.0 * texture(u_fragmentMap0, var_TexNormal.st).agb - 1.0);\n"
        "#endif\n"
        "\n"
        "	float NdotL = clamp(dot(N, L), 0.0, 1.0);\n"
        "#if defined(HALF_LAMBERT)\n"
        "	NdotL *= 0.5;\n"
        "	NdotL += 0.5;\n"
        "	NdotL = NdotL * NdotL;\n"
        "#endif\n"
        "#if defined(BLINN_PHONG)\n"
        "	float NdotH = clamp(dot(N, H), 0.0, 1.0);\n"
        "#endif\n"
        "\n"
        "	vec3 lightProjection = textureProj(u_fragmentMap2, var_TexLight.xyw).rgb;\n"
        "	vec3 lightFalloff = texture(u_fragmentMap1, vec2(var_TexLight.z, 0.5)).rgb;\n"
        "	vec3 diffuseColor = texture(u_fragmentMap3, var_TexDiffuse).rgb * u_diffuseColor.rgb;\n"
        "	vec3 specularColor = 2.0 * texture(u_fragmentMap4, var_TexSpecular).rgb * u_specularColor.rgb;\n"
        "\n"
        "#if defined(BLINN_PHONG)\n"
        "	float specularFalloff = pow(NdotH, u_specularExponent);\n"
        "#else\n"
        "	vec3 R = -reflect(L, N);\n"
        "	float RdotV = clamp(dot(R, V), 0.0, 1.0);\n"
        "	float specularFalloff = pow(RdotV, u_specularExponent);\n"
        "#endif\n"
        "\n"
		"highp float shadow = 0.0;\n"
		"#define SAMPLES 9\n"
        "\n"
		"vec2 sampleOffsetTable[SAMPLES] = vec2[SAMPLES](\n"
		"	vec2(0.0, 0.0),\n"
		"	vec2(1.0, 1.0), vec2(1.0, -1.0), vec2(-1.0, -1.0), vec2(-1.0, 1.0),\n"
		"	vec2(1.0, 0.0), vec2(-1.0, 0.0), vec2(0.0, -1.0), vec2(0.0, 1.0)\n"
        ");\n"
		"#ifdef _POINT_LIGHT\n"
		"	int shadowIndex = 0;\n"
		"	highp vec3 toLightGlobal = normalize( var_VertexToLight );\n"
		"	highp float axis[6] = float[6](\n"
		"		-toLightGlobal.x,\n"
		"		toLightGlobal.x,\n"
		"		-toLightGlobal.y,\n"
		"		toLightGlobal.y,\n"
		"		-toLightGlobal.z,\n"
		"		toLightGlobal.z\n"
        "	);\n"
		"	for( int i = 0; i < 6; i++ ) {\n"
		"		//if( axis[i] > axis[shadowIndex] ) {		shadowIndex = i;	}\n"
		"		shadowIndex = axis[i] > axis[shadowIndex] ? i : shadowIndex;\n"
		"	}\n"
		"	highp vec4 shadowPosition = var_VertexPosition * shadowMVPMatrix[shadowIndex];\n"
		"	//vec3 c; if(shadowIndex == 0) c = vec3(1.0, 0.0, 0.0); else if(shadowIndex == 1) c = vec3(1.0, 1.0, 0.0); else if(shadowIndex == 2) c = vec3(0.0, 1.0, 0.0); else if(shadowIndex == 3) c = vec3(0.0, 1.0, 1.0); else if(shadowIndex == 4) c = vec3(0.0, 0.0, 1.0); else c = vec3(1.0, 0.0, 1.0);\n"
		"	shadowPosition.xyz /= shadowPosition.w;\n"
		"	shadowPosition.w = float(shadowIndex);\n"
        "	highp float distance = u_uniformParm2 + length(var_VertexToLight) * (0.00000000002 * u_uniformParm6); // more far more large // length(var_VertexToLight) / (100000000000.0 * u_uniformParm5)\n"
		"#else\n"
		"	highp vec4 shadowPosition = vec4(var_ShadowCoord.xyz / var_ShadowCoord.w, 0.0);\n"
        "	highp float distance = u_uniformParm2;\n"
		"#endif\n"
		"   // end light type\n"
		"	shadowPosition.z = BIAS(shadowPosition.z);\n"
		"	for (int i = 0; i < SAMPLES; ++i) {\n"
		"		highp float shadowDepth = texture(u_fragmentMap6, vec4(shadowPosition.st + sampleOffsetTable[i] * distance, shadowPosition.wz));\n"
		"		shadow += 1.0 - (1.0 - shadowDepth) * u_uniformParm3;\n"
		"		//shadow += shadowDepth > 0.0 ? 1.0 : u_uniformParm3;\n"
		"	}\n"
		"	const highp float sampleAvg = 1.0 / float(SAMPLES);\n"
        "	shadow *= sampleAvg;\n"
		"\n"
        "	vec3 color;\n"
        "	color = diffuseColor;\n"
        "	color += specularFalloff * specularColor;\n"
        "	color *= NdotL * lightProjection;\n"
        "	color *= lightFalloff;\n"
		"	color *= shadow;\n"
        "\n"
        "	_gl_FragColor = vec4(color, 1.0) * var_Color;\n"
        "}\n"
;

// z-fill perforated depth
GLSL_SHADER const char ES3_DEPTH_PERFORATED_VERT[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"in vec4 attr_TexCoord;\n"
"in highp vec4 attr_Vertex;\n"
"\n"
"uniform mat4 u_textureMatrix;\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"\n"
"out vec2 var_TexDiffuse;\n"
"\n"
"void main(void)\n"
"{\n"
"	var_TexDiffuse = (u_textureMatrix * attr_TexCoord).xy;\n"
"\n"
"	gl_Position = attr_Vertex * u_modelViewProjectionMatrix;\n"
"}\n"
;
GLSL_SHADER const char ES3_DEPTH_PERFORATED_FRAG[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"uniform sampler2D u_fragmentMap0;\n"
"uniform lowp float u_alphaTest;\n"
"uniform lowp vec4 u_glColor;\n"
"\n"
"in vec2 var_TexDiffuse;\n"
"#ifdef _DEBUG\n"
"out vec4 _gl_FragColor;\n"
"#endif\n"
"\n"
"void main(void)\n"
"{\n"
	"if (u_alphaTest > texture(u_fragmentMap0, var_TexDiffuse).a) {\n"
		"discard;\n"
	"}\n"
"\n"
"#ifdef _DEBUG\n"
"    _gl_FragColor = vec4((gl_FragCoord.z + 1.0) * 0.5, 0.0, 0.0, 1.0); // DEBUG\n"
"#endif\n"
"}\n"
;
#endif

#ifdef _TRANSLUCENT_STENCIL_SHADOW
// interaction(translucent)
GLSL_SHADER const char ES3_INTERACTION_TRANSLUCENT_VERT[] =
		"#version 300 es\n"
		"//#pragma optimize(off)\n"
		"\n"
		"precision highp float;\n"
		"\n"
		"//#define BLINN_PHONG\n"
		"\n"
		"out vec2 var_TexDiffuse;\n"
		"out vec2 var_TexNormal;\n"
		"out vec2 var_TexSpecular;\n"
		"out vec4 var_TexLight;\n"
		"out lowp vec4 var_Color;\n"
		"out vec3 var_L;\n"
		"#if defined(BLINN_PHONG)\n"
		"out vec3 var_H;\n"
		"#else\n"
		"out vec3 var_V;\n"
		"#endif\n"
		"\n"
		"in vec4 attr_TexCoord;\n"
		"in vec3 attr_Tangent;\n"
		"in vec3 attr_Bitangent;\n"
		"in vec3 attr_Normal;\n"
		"in highp vec4 attr_Vertex;\n"
		"in lowp vec4 attr_Color;\n"
		"\n"
		"uniform vec4 u_lightProjectionS;\n"
		"uniform vec4 u_lightProjectionT;\n"
		"uniform vec4 u_lightFalloff;\n"
		"uniform vec4 u_lightProjectionQ;\n"
		"uniform lowp vec4 u_colorModulate;\n"
		"uniform lowp vec4 u_colorAdd;\n"
		"uniform lowp vec4 u_glColor;\n"
		"\n"
		"uniform vec4 u_lightOrigin;\n"
		"uniform vec4 u_viewOrigin;\n"
		"\n"
		"uniform vec4 u_bumpMatrixS;\n"
		"uniform vec4 u_bumpMatrixT;\n"
		"uniform vec4 u_diffuseMatrixS;\n"
		"uniform vec4 u_diffuseMatrixT;\n"
		"uniform vec4 u_specularMatrixS;\n"
		"uniform vec4 u_specularMatrixT;\n"
		"\n"
		"uniform highp mat4 u_modelViewProjectionMatrix;\n"
		"\n"
		"void main(void)\n"
		"{\n"
		"mat3 M = mat3(attr_Tangent, attr_Bitangent, attr_Normal);\n"
		"\n"
		"var_TexNormal.x = dot(u_bumpMatrixS, attr_TexCoord);\n"
		"var_TexNormal.y = dot(u_bumpMatrixT, attr_TexCoord);\n"
		"\n"
		"var_TexDiffuse.x = dot(u_diffuseMatrixS, attr_TexCoord);\n"
		"var_TexDiffuse.y = dot(u_diffuseMatrixT, attr_TexCoord);\n"
		"\n"
		"var_TexSpecular.x = dot(u_specularMatrixS, attr_TexCoord);\n"
		"var_TexSpecular.y = dot(u_specularMatrixT, attr_TexCoord);\n"
		"\n"
		"var_TexLight.x = dot(u_lightProjectionS, attr_Vertex);\n"
		"var_TexLight.y = dot(u_lightProjectionT, attr_Vertex);\n"
		"var_TexLight.z = dot(u_lightFalloff, attr_Vertex);\n"
		"var_TexLight.w = dot(u_lightProjectionQ, attr_Vertex);\n"
		"\n"
		"vec3 L = u_lightOrigin.xyz - attr_Vertex.xyz;\n"
		"vec3 V = u_viewOrigin.xyz - attr_Vertex.xyz;\n"
		"#if defined(BLINN_PHONG)\n"
		"vec3 H = normalize(L) + normalize(V);\n"
		"#endif\n"
		"\n"
		"var_L = L * M;\n"
		"#if defined(BLINN_PHONG)\n"
		"var_H = H * M;\n"
		"#else\n"
		"var_V = V * M;\n"
		"#endif\n"
		"\n"
		"var_Color = (attr_Color / 255.0) * u_colorModulate + u_colorAdd;\n"
		"\n"
		"gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
		"}\n"
;
GLSL_SHADER const char ES3_INTERACTION_TRANSLUCENT_FRAG[] =
		"#version 300 es\n"
		"//#pragma optimize(off)\n"
		"\n"
		"precision highp float;\n"
		"\n"
		"//#define BLINN_PHONG\n"
		"\n"
		"//#define HALF_LAMBERT\n"
		"\n"
		"in vec2 var_TexDiffuse;\n"
		"in vec2 var_TexNormal;\n"
		"in vec2 var_TexSpecular;\n"
		"in vec4 var_TexLight;\n"
		"in lowp vec4 var_Color;\n"
		"in vec3 var_L;\n"
		"#if defined(BLINN_PHONG)\n"
		"in vec3 var_H;\n"
		"#else\n"
		"in vec3 var_V;\n"
		"#endif\n"
		"\n"
		"uniform vec4 u_diffuseColor;\n"
		"uniform vec4 u_specularColor;\n"
		"uniform float u_specularExponent;\n"
		"\n"
		"uniform sampler2D u_fragmentMap0;	/* u_bumpTexture */\n"
		"uniform sampler2D u_fragmentMap1;	/* u_lightFalloffTexture */\n"
		"uniform sampler2D u_fragmentMap2;	/* u_lightProjectionTexture */\n"
		"uniform sampler2D u_fragmentMap3;	/* u_diffuseTexture */\n"
		"uniform sampler2D u_fragmentMap4;	/* u_specularTexture */\n"
		"uniform sampler2D u_fragmentMap5;	/* u_specularFalloffTexture */\n"
		"uniform lowp float u_uniformParm0; // shadow alpha\n"
		"out vec4 _gl_FragColor;\n"
		"\n"
		"void main(void)\n"
		"{\n"
		"//float u_specularExponent = 4.0;\n"
		"\n"
		"vec3 L = normalize(var_L);\n"
		"#if defined(BLINN_PHONG)\n"
		"vec3 H = normalize(var_H);\n"
		"vec3 N = 2.0 * texture(u_fragmentMap0, var_TexNormal.st).agb - 1.0;\n"
		"#else\n"
		"vec3 V = normalize(var_V);\n"
		"vec3 N = normalize(2.0 * texture(u_fragmentMap0, var_TexNormal.st).agb - 1.0);\n"
		"#endif\n"
		"\n"
		"float NdotL = clamp(dot(N, L), 0.0, 1.0);\n"
		"#if defined(HALF_LAMBERT)\n"
		"NdotL *= 0.5;\n"
		"NdotL += 0.5;\n"
		"NdotL = NdotL * NdotL;\n"
		"#endif\n"
		"#if defined(BLINN_PHONG)\n"
		"float NdotH = clamp(dot(N, H), 0.0, 1.0);\n"
		"#endif\n"
		"\n"
		"vec3 lightProjection = textureProj(u_fragmentMap2, var_TexLight.xyw).rgb;\n"
		"vec3 lightFalloff = texture(u_fragmentMap1, vec2(var_TexLight.z, 0.5)).rgb;\n"
		"vec3 diffuseColor = texture(u_fragmentMap3, var_TexDiffuse).rgb * u_diffuseColor.rgb;\n"
		"vec3 specularColor = 2.0 * texture(u_fragmentMap4, var_TexSpecular).rgb * u_specularColor.rgb;\n"
		"\n"
		"#if defined(BLINN_PHONG)\n"
		"float specularFalloff = pow(NdotH, u_specularExponent);\n"
		"#else\n"
		"vec3 R = -reflect(L, N);\n"
		"float RdotV = clamp(dot(R, V), 0.0, 1.0);\n"
		"float specularFalloff = pow(RdotV, u_specularExponent);\n"
		"#endif\n"
		"\n"
		"vec3 color;\n"
		"color = diffuseColor;\n"
		"color += specularFalloff * specularColor;\n"
		"color *= NdotL * lightProjection;\n"
		"color *= lightFalloff;\n"
		"\n"
		"_gl_FragColor = vec4(color, 1.0) * var_Color * u_uniformParm0;\n"
		"}\n"
;
#endif

#endif
